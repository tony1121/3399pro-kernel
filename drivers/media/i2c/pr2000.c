// SPDX-License-Identifier: GPL-2.0
/*
 * pr2000 driver
 *
 * Copyright (C) 2019 Kaspter Ju camus@rtavs.com.
 */

#include <linux/clk.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <linux/sysfs.h>
#include <media/media-entity.h>
#include <media/v4l2-async.h>
#include <media/v4l2-ctrls.h>
#include <media/v4l2-subdev.h>


#define PR2000_XVCLK_FREQ		27000000
#define PR2000_SKIP_TOP		24

#define REG_NULL            0x5a
#define CHIP_ID             0x2000


//#define PR2000_LINK_FREQ		74250000
#define PR2000_LINK_FREQ		148500000
//#define PR2000_LINK_FREQ		297000000

/* pixel_rate = link_freq * 2 * nr_of_lanes / bits_per_sample */
#define PR2000_PIXEL_RATE		(PR2000_LINK_FREQ * 2 * 4 / 8)
static const s64 link_freq_menu_items[] = {
	PR2000_LINK_FREQ
};

static const char * const pr2000_supply_names[] = {
    "vdd33",
    "vdd12",
};

#define PR2000_NUM_SUPPLIES ARRAY_SIZE(pr2000_supply_names)

struct regval {
    u8 addr;
    u8 val;
};


struct pr2000_mode {
    u32 width;
    u32 height;
    u32 interlace;
    const struct regval *reg_list;
};

struct pr2000 {
    struct i2c_client   *client;
    struct clk          *xvclk;
    struct gpio_desc    *reset_gpio;
    struct gpio_desc    *pwdn_gpio;
    struct regulator_bulk_data supplies[PR2000_NUM_SUPPLIES];

    bool                streaming;
    struct mutex        mutex; /* lock to serialize v4l2 callback */
    struct v4l2_subdev  subdev;
    struct media_pad    pad;

    struct v4l2_ctrl_handler ctrl_handler;

    int         skip_top;

    v4l2_std_id             std; /* Current set standard */
    const struct pr2000_mode *cur_mode;
};


#define to_pr2000(sd) container_of(sd, struct pr2000, subdev)


static struct regval pr2000_mipi_start[] = {
    // Start mipi 4lane
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x40},
    {0xff, 0x00},
    {0x40, 0x40},
    {0xff, 0x00},
    {0x4e, 0x60},
    {0xff, 0x00},
    {0x4e, 0x40},
    {0xff, 0x00},
    {REG_NULL, 0x0},
};

static struct regval pr2000_mipi_stop[] = {
    // Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},
    {REG_NULL, 0x0},
};


static struct regval pr2000_initial[] = {
    {0xff,0x00},
    {0xd0,0x30},
    {0xd1,0x08},
    {0xd2,0x21},
    {0xd3,0x00},
    {0xd4,0x00},
    {0xd5,0x00},
    {0xd6,0x00},
    {0xd7,0x00},
    {0xd8,0x30},
    {0xd9,0x08},
    {0xda,0x21},
    {0xdb,0x00},
    {0xdc,0x00},
    {0xdd,0x00},
    {0xde,0x00},
    {0xdf,0x00},

    {0xff,0x01},
    {0x00,0xe4},
    {0x01,0x61},
    {0x02,0x00},
    {0x03,0x56},
    {0x04,0x0c},
    {0x05,0x88},
    {0x06,0x04},
    {0x07,0xb2},
    {0x08,0x44},
    {0x09,0x34},
    {0x0a,0x02},
    {0x0b,0x14},
    {0x0c,0x04},
    {0x0d,0x08},
    {0x0e,0x5e},
    {0x0f,0x5e},
    {0x10,0x26},
    {REG_NULL, 0x0},
};


//Camera:0(SD), cameraResolution:0(camera_ntsc), videoResolution:0(video_720x480i60), MIPI 4 lane
static struct regval pr2000_ntsc[] = {
    //Page0 sys
    {0xff, 0x00},
    {0x10, 0x30},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0] => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},
    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xb6},
    {0x48, 0xa0},
    {0x49, 0x05},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
    {0xa0, 0x01},
    {0xa1, 0xe8},
    {0xa4, 0x00},
    {0xa5, 0x11},
    {0xa6, 0x00},
    {0xa7, 0x81},
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x1e},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

//                      Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4},
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x00},
    {0x12, 0x02},
    {0x13, 0x90},
    {0x14, 0xd0},
    {0x15, 0x10},
    {0x16, 0xf0},
    {0x17, 0x00},
    {0x18, 0x21},
    {0x19, 0x4a},
    {0x1a, 0x20},
    {0x1b, 0x07},
    {0x1c, 0x00},
    {0x1d, 0x42},
    {0x1e, 0x40},
    {0x1f, 0xd0},
    {0x20, 0x80},
    {0x21, 0x88},
    {0x22, 0x80},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x80},
    {0x28, 0x00},
    {0x29, 0x5f},
    {0x2a, 0x20},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x14},
    {0x34, 0x14},
    {0x35, 0x80},
    {0x36, 0x80},
    {0x37, 0xe2},
    {0x38, 0x41},
    {0x39, 0x00},
    {0x3a, 0xac},
    {0x3b, 0x04},
    {0x3c, 0x01},
    {0x3d, 0x21},
    {0x3e, 0x06},
    {0x3f, 0xd5},
    {0x40, 0x05},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x30},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x06},
    {0x47, 0x2b},
    {0x48, 0xb9},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x47},
    {0x4e, 0x02},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x04},
    {0x89, 0x48},
    {0x8a, 0x04},
    {0x8b, 0x48},
    {0x8c, 0x05},
    {0x8d, 0xf0},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x03},
    {0x91, 0x13},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x03},
    {0x97, 0xd0},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x04},
    {0xb1, 0xd4},
    {0xb2, 0x07},
    {0xb3, 0xda},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x17},
    {0xbc, 0x00},
    {0xbd, 0x04},
    {0xbe, 0x02},
    {0xbf, 0xd0},
    {0xc0, 0x00},
    {0xc1, 0x10},
    {0xc2, 0x00},
    {0xc3, 0xf0},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},

//                      Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},

    {REG_NULL, 0x0},
};

#if 1
//Camera:0(SD), cameraResolution:1(camera_pal), videoResolution:1(video_720x576i50), MIPI 4 lane
static struct regval pr2000_pal[] = {
    // Page0 sys
    {0xff, 0x00},
    {0x10, 0x21},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0] => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},

    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xb6},
    {0x48, 0xa0},
    {0x49, 0x05},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
#if 0
    {0xa0, 0x00},
    {0xa1, 0x20},
    {0xa4, 0x01},
    {0xa5, 0xe3},
#else
    {0xa0, 0x01},
    {0xa1, 0xe8},
    {0xa4, 0x00},
    {0xa5, 0x11},
#endif
    {0xa6, 0x00},

#if 0
    {0xa7, 0x12},
#else
    {0xa7, 0x81},
#endif
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x1e},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

    // Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4}, // 0xe4 0XE7 Blue background
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x00},
    {0x12, 0x22},
    {0x13, 0xe0},
    {0x14, 0xd0},
    {0x15, 0x16},
    {0x16, 0x20},
    {0x17, 0x00},
    {0x18, 0x21},
    {0x19, 0x4a},
    {0x1a, 0x20},
    {0x1b, 0x06},
    {0x1c, 0x31},
    {0x1d, 0x42},
    {0x1e, 0x50},
    {0x1f, 0xd0},
    {0x20, 0x80},
    {0x21, 0x88},
    {0x22, 0x80},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x80},
    {0x28, 0x00},
    {0x29, 0x5f},
    {0x2a, 0x20},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x20},
    {0x34, 0x20},
    {0x35, 0x10},
    {0x36, 0x10},
    {0x37, 0xc4},
    {0x38, 0x42},
    {0x39, 0x00},
    {0x3a, 0xac},
    {0x3b, 0x04},
    {0x3c, 0x01},
    {0x3d, 0x21},
    {0x3e, 0x06},
    {0x3f, 0xd5},
    {0x40, 0x85},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x31},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x07},
    {0x47, 0xa4},
    {0x48, 0xa5},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x47},
    {0x4e, 0x02},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x05},
    {0x89, 0x24},
    {0x8a, 0x05},
    {0x8b, 0x24},
    {0x8c, 0x05},
    {0x8d, 0xf0},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x02},
    {0x91, 0xb4},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x03},
    {0x97, 0xd0},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x05},
    {0xb1, 0xcc},
    {0xb2, 0x09},
    {0xb3, 0x6d},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x17},
    {0xbc, 0x00},
    {0xbd, 0x04},
    {0xbe, 0x02},
    {0xbf, 0xd0},
    {0xc0, 0x00},
    {0xc1, 0x18},
    {0xc2, 0x01},
    {0xc3, 0x20},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},


    //Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},

    {REG_NULL, 0x0},
};

#endif

//Camera:3(HDA), cameraResolution:5(camera_1280x720p25), videoResolution:7(video_1280x720p25), MIPI 4lane
static struct regval pr2000_720p25[] = {
    // Page0 sys
    {0xff, 0x00},
    {0x10, 0x82},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0}, => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},
    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xba},
    {0x48, 0x00},
    {0x49, 0x0a},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
#if 0
    {0xa0, 0x00},
    {0xa1, 0x20},
    {0xa4, 0x01},
    {0xa5, 0xe3},
#else
    {0xa0, 0x01},
    {0xa1, 0xe8},
    {0xa4, 0x00},
    {0xa5, 0x11},
#endif
    {0xa6, 0x00},
#if 0
    {0xa7, 0x12},
#else
    {0xa7, 0x81},
#endif
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x19},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

    // Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4}, //0XE4     0XE7 Blue background
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x01},
    {0x12, 0x45},
    {0x13, 0x0c},
    {0x14, 0x00},
    {0x15, 0x1b},
    {0x16, 0xd0},
    {0x17, 0x00},
    {0x18, 0x41},
    {0x19, 0x46},
    {0x1a, 0x22},
    {0x1b, 0x05},
    {0x1c, 0xea},
    {0x1d, 0x45},
    {0x1e, 0x4c},
    {0x1f, 0x00},
    {0x20, 0x80},
    {0x21, 0x80},
    {0x22, 0x90},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x82},
    {0x28, 0x00},
    {0x29, 0x7d},
    {0x2a, 0x00},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x14},
    {0x34, 0x14},
    {0x35, 0x80},
    {0x36, 0x80},
    {0x37, 0xaa},
    {0x38, 0x48},
    {0x39, 0x08},
    {0x3a, 0x27},
    {0x3b, 0x02},
    {0x3c, 0x01},
    {0x3d, 0x23},
    {0x3e, 0x02},
    {0x3f, 0xc4},
    {0x40, 0x05},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x33},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x09},
    {0x47, 0xe2},
    {0x48, 0x01},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x4a},
    {0x4e, 0x00},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x0a},
    {0x89, 0x48},
    {0x8a, 0x0a},
    {0x8b, 0x48},
    {0x8c, 0x0b},
    {0x8d, 0xe0},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x05},
    {0x91, 0x69},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x07},
    {0x97, 0x90},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x0b},
    {0xb1, 0x99},
    {0xb2, 0x12},
    {0xb3, 0xca},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x03},
    {0xbc, 0x00},
    {0xbd, 0x04},   // lr
    {0xbe, 0x05},
    {0xbf, 0x00},
    {0xc0, 0x00},
    {0xc1, 0x1c},   // tb
    {0xc2, 0x02},
    {0xc3, 0xd0},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},

    // Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},

#if 0
    // color bar
    {0xff, 0x01},
    {0x4f, 0x14},
    {0xff, 0x02},
    {0x80, 0xb0},
    {0x82, 0x10},
#endif
    {REG_NULL, 0x0},
};


//Camera:3(HDA), cameraResolution:4(camera_1280x720p30), videoResolution:6(video_1280x720p30), MIPI 4lane
static struct regval pr2000_720p30[] = {
    // Page0 sys
    {0xff, 0x00},
    {0x10, 0x92},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0}, => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},
    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xba},
    {0x48, 0x00},
    {0x49, 0x0a},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
    {0xa0, 0x00},
    {0xa1, 0x20},
    {0xa4, 0x01},
    {0xa5, 0xe3},
    {0xa6, 0x00},
    {0xa7, 0x12},
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x19},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

    //  Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4},
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x00},
    {0x12, 0x45},
    {0x13, 0xfc},
    {0x14, 0x00},
    {0x15, 0x18},
    {0x16, 0xd0},
    {0x17, 0x00},
    {0x18, 0x41},
    {0x19, 0x46},
    {0x1a, 0x22},
    {0x1b, 0x05},
    {0x1c, 0xea},
    {0x1d, 0x45},
    {0x1e, 0x40},
    {0x1f, 0x00},
    {0x20, 0x80},
    {0x21, 0x80},
    {0x22, 0x90},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x82},
    {0x28, 0x00},
    {0x29, 0x7b},
    {0x2a, 0xa6},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x14},
    {0x34, 0x14},
    {0x35, 0x80},
    {0x36, 0x80},
    {0x37, 0xaa},
    {0x38, 0x48},
    {0x39, 0x08},
    {0x3a, 0x27},
    {0x3b, 0x02},
    {0x3c, 0x01},
    {0x3d, 0x23},
    {0x3e, 0x02},
    {0x3f, 0xc4},
    {0x40, 0x05},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x33},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x09},
    {0x47, 0xdc},
    {0x48, 0xa0},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x4a},
    {0x4e, 0x00},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x08},
    {0x89, 0x91},
    {0x8a, 0x08},
    {0x8b, 0x91},
    {0x8c, 0x0b},
    {0x8d, 0xe0},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x05},
    {0x91, 0xa0},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x07},
    {0x97, 0x90},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x09},
    {0xb1, 0xaa},
    {0xb2, 0x0f},
    {0xb3, 0xae},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x03},
    {0xbc, 0x00},
    {0xbd, 0x04},
    {0xbe, 0x05},
    {0xbf, 0x00},
    {0xc0, 0x00},
    {0xc1, 0x18},
    {0xc2, 0x02},
    {0xc3, 0xd0},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},


//   Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},
    {REG_NULL, 0x0},
};



//Camera:3(HDA), cameraResolution:7(camera_1920x1080p25), videoResolution:9(video_1920x1080p25), MIPI 4lane
static struct regval pr2000_1080p25[] = {
    {0xff, 0x00},
    {0x10, 0x83},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0}, => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},
    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xba},
    {0x48, 0x00},
    {0x49, 0x0f},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
    {0xa0, 0x01},
    {0xa1, 0xe8},
    {0xa4, 0x00},
    {0xa5, 0x11},
    {0xa6, 0x00},
    {0xa7, 0x81},
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x15},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

//                      Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4},
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x00},
    {0x12, 0x87},
    {0x13, 0x24},
    {0x14, 0x80},
    {0x15, 0x2a},
    {0x16, 0x38},
    {0x17, 0x00},
    {0x18, 0x80},
    {0x19, 0x48},
    {0x1a, 0x6c},
    {0x1b, 0x05},
    {0x1c, 0x61},
    {0x1d, 0x07},
    {0x1e, 0x7e},
    {0x1f, 0x80},
    {0x20, 0x80},
    {0x21, 0x80},
    {0x22, 0x90},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x82},
    {0x28, 0x00},
    {0x29, 0xff},
    {0x2a, 0xff},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x14},
    {0x34, 0x14},
    {0x35, 0x80},
    {0x36, 0x80},
    {0x37, 0xad},
    {0x38, 0x4b},
    {0x39, 0x08},
    {0x3a, 0x21},
    {0x3b, 0x02},
    {0x3c, 0x01},
    {0x3d, 0x23},
    {0x3e, 0x05},
    {0x3f, 0xc8},
    {0x40, 0x05},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x38},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x14},
    {0x47, 0xb0},
    {0x48, 0xdf},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x26},
    {0x4e, 0x00},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x05},
    {0x89, 0x24},
    {0x8a, 0x05},
    {0x8b, 0x24},
    {0x8c, 0x08},
    {0x8d, 0xe8},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x02},
    {0x91, 0xb4},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x03},
    {0x97, 0xd0},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x05},
    {0xb1, 0xcc},
    {0xb2, 0x09},
    {0xb3, 0x6d},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x03},
    {0xbc, 0x00},
    {0xbd, 0x04},
    {0xbe, 0x07},
    {0xbf, 0x80},
    {0xc0, 0x00},
    {0xc1, 0x20},
    {0xc2, 0x04},
    {0xc3, 0x38},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},


//                      Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},

    {REG_NULL, 0x0},
};


//Camera:3(HDA), cameraResolution:6(camera_1920x1080p30), videoResolution:8(video_1920x1080p30), MIPI 4lane
static struct regval pr2000_1080p30[] = {
	//  Page0 sys
    {0xff, 0x00},
    {0x10, 0x93},
    {0x11, 0x07},
    {0x12, 0x00},
    {0x13, 0x00},
    {0x14, 0x21},    //b[1:0] => Select Camera Input. VinP(1), VinN(3), Differ(0).
    {0x15, 0x44},
    {0x16, 0x0d},
    {0x40, 0x00},
    {0x41, 0x08},
    {0x42, 0x00},
    {0x43, 0x00},
    {0x47, 0xba},
    {0x48, 0x00},
    {0x49, 0x0f},
    {0x4e, 0x40},
    {0x80, 0x56},
    {0x81, 0x0e},
    {0x82, 0x0d},
    {0x84, 0x30},
    {0x86, 0x20},
    {0x87, 0x00},
    {0x8a, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x94, 0xff},
    {0x95, 0xff},
    {0x96, 0xff},
    {0xa0, 0x01},
    {0xa1, 0xe8},
    {0xa4, 0x00},
    {0xa5, 0x11},
    {0xa6, 0x00},
    {0xa7, 0x81},
    {0xa8, 0x00},
    {0xd0, 0x30},
    {0xd1, 0x08},
    {0xd2, 0x21},
    {0xd3, 0x00},
    {0xd8, 0x37},
    {0xd9, 0x08},
    {0xda, 0x21},
    {0xe0, 0x15},
    {0xe1, 0x00},
    {0xe2, 0x18},
    {0xe3, 0x00},
    {0xe4, 0x00},
    {0xe5, 0x0c},
    {0xe6, 0x00},
    {0xea, 0x00},
    {0xeb, 0x00},
    {0xf1, 0x44},
    {0xf2, 0x01},

	// Page1 vdec
    {0xff, 0x01},
    {0x00, 0xe4},
    {0x01, 0x61},
    {0x02, 0x00},
    {0x03, 0x57},
    {0x04, 0x0c},
    {0x05, 0x88},
    {0x06, 0x04},
    {0x07, 0xb2},
    {0x08, 0x44},
    {0x09, 0x34},
    {0x0a, 0x02},
    {0x0b, 0x14},
    {0x0c, 0x04},
    {0x0d, 0x08},
    {0x0e, 0x5e},
    {0x0f, 0x5e},
    {0x10, 0x26},
    {0x11, 0x00},
    {0x12, 0x87},
    {0x13, 0x2c},
    {0x14, 0x80},
    {0x15, 0x28},
    {0x16, 0x38},
    {0x17, 0x00},
    {0x18, 0x80},
    {0x19, 0x48},
    {0x1a, 0x6c},
    {0x1b, 0x05},
    {0x1c, 0x61},
    {0x1d, 0x07},
    {0x1e, 0x7e},
    {0x1f, 0x80},
    {0x20, 0x80},
    {0x21, 0x80},
    {0x22, 0x90},
    {0x23, 0x80},
    {0x24, 0x80},
    {0x25, 0x80},
    {0x26, 0x84},
    {0x27, 0x82},
    {0x28, 0x00},
    {0x29, 0xff},
    {0x2a, 0xff},
    {0x2b, 0x00},
    {0x2c, 0x00},
    {0x2d, 0x00},
    {0x2e, 0x00},
    {0x2f, 0x00},
    {0x30, 0x00},
    {0x31, 0x00},
    {0x32, 0xc0},
    {0x33, 0x14},
    {0x34, 0x14},
    {0x35, 0x80},
    {0x36, 0x80},
    {0x37, 0xad},
    {0x38, 0x4b},
    {0x39, 0x08},
    {0x3a, 0x21},
    {0x3b, 0x02},
    {0x3c, 0x01},
    {0x3d, 0x23},
    {0x3e, 0x05},
    {0x3f, 0xc8},
    {0x40, 0x05},
    {0x41, 0x55},
    {0x42, 0x01},
    {0x43, 0x38},
    {0x44, 0x6a},
    {0x45, 0x00},
    {0x46, 0x14},
    {0x47, 0xb2},
    {0x48, 0xbc},
    {0x49, 0x00},
    {0x4a, 0x7b},
    {0x4b, 0x60},
    {0x4c, 0x00},
    {0x4d, 0x26},
    {0x4e, 0x00},
    {0x4f, 0x04},
    {0x50, 0x01},
    {0x51, 0x28},
    {0x52, 0x40},
    {0x53, 0x0c},
    {0x54, 0x0f},
    {0x55, 0x8d},
    {0x70, 0x06},
    {0x71, 0x08},
    {0x72, 0x0a},
    {0x73, 0x0c},
    {0x74, 0x0e},
    {0x75, 0x10},
    {0x76, 0x12},
    {0x77, 0x14},
    {0x78, 0x06},
    {0x79, 0x08},
    {0x7a, 0x0a},
    {0x7b, 0x0c},
    {0x7c, 0x0e},
    {0x7d, 0x10},
    {0x7e, 0x12},
    {0x7f, 0x14},
    {0x80, 0x00},
    {0x81, 0x09},
    {0x82, 0x00},
    {0x83, 0x07},
    {0x84, 0x00},
    {0x85, 0x17},
    {0x86, 0x03},
    {0x87, 0xe5},
    {0x88, 0x04},
    {0x89, 0x48},
    {0x8a, 0x04},
    {0x8b, 0x48},
    {0x8c, 0x08},
    {0x8d, 0xe8},
    {0x8e, 0x05},
    {0x8f, 0x47},
    {0x90, 0x03},
    {0x91, 0x13},
    {0x92, 0x73},
    {0x93, 0xe8},
    {0x94, 0x0f},
    {0x95, 0x5e},
    {0x96, 0x03},
    {0x97, 0xd0},
    {0x98, 0x17},
    {0x99, 0x34},
    {0x9a, 0x13},
    {0x9b, 0x56},
    {0x9c, 0x0b},
    {0x9d, 0x9a},
    {0x9e, 0x09},
    {0x9f, 0xab},
    {0xa0, 0x01},
    {0xa1, 0x74},
    {0xa2, 0x01},
    {0xa3, 0x6b},
    {0xa4, 0x00},
    {0xa5, 0xba},
    {0xa6, 0x00},
    {0xa7, 0xa3},
    {0xa8, 0x01},
    {0xa9, 0x39},
    {0xaa, 0x01},
    {0xab, 0x39},
    {0xac, 0x00},
    {0xad, 0xc1},
    {0xae, 0x00},
    {0xaf, 0xc1},
    {0xb0, 0x04},
    {0xb1, 0xd4},
    {0xb2, 0x07},
    {0xb3, 0xda},
    {0xb4, 0x00},
    {0xb5, 0x17},
    {0xb6, 0x08},
    {0xb7, 0xe8},
    {0xb8, 0xb0},
    {0xb9, 0xce},
    {0xba, 0x90},
    {0xbb, 0x03},
    {0xbc, 0x00},
    {0xbd, 0x04},
    {0xbe, 0x07},
    {0xbf, 0x80},
    {0xc0, 0x00},
    {0xc1, 0x20},
    {0xc2, 0x04},
    {0xc3, 0x38},

    {0xff, 0x01},
    {0x54, 0x0e},
    {0xff, 0x01},
    {0x54, 0x0f},


	// Stop mipi 4lane
    {0xff, 0x00},
    {0x47, 0x3a},
    {0xff, 0x00},
    {0x40, 0x00},
    {0xff, 0x00},
    {0x4e, 0x7f},

    {REG_NULL, 0x0},
};


static const struct pr2000_mode supported_modes[] = {
    {
        .width = 720,
        .height = 480,
        .interlace = 1,
        .reg_list = pr2000_ntsc,
    },
#if 1
    {
        .width = 720,
        .height = 576,
        .interlace = 1,
        .reg_list = pr2000_pal,
    },
#endif
    {
        .width = 1280,
        .height = 720,
        .interlace = 0,
        .reg_list = pr2000_720p25,
    },
    {
        .width = 1280,
        .height = 720,
        .interlace = 0,
        .reg_list = pr2000_720p30,
    },
    {
        .width = 1920,
        .height = 1080,
        .interlace = 0,
        .reg_list = pr2000_1080p25,
    },
    {
        .width = 1920,
        .height = 1080,
        .interlace = 0,
        .reg_list = pr2000_1080p30,
    },
};

static int pr2000_write_reg(struct i2c_client *client, u8 reg, u8 val)
{
    int ret;

    ret = i2c_smbus_write_byte_data(client, reg, val);

    if (ret < 0)
        dev_err(&client->dev, "write reg error: %d\n", ret);

    return ret;
}

static int pr2000_write_array(struct i2c_client *client,
                   const struct regval *regs)
{
    int i, ret = 0;

    for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
        ret = pr2000_write_reg(client, regs[i].addr, regs[i].val);

    return ret;
}

static inline u8 pr2000_read_reg(struct i2c_client *client, u8 reg)
{
    return i2c_smbus_read_byte_data(client, reg);
}

static void pr2000_soft_reset(struct pr2000 *pr2000)
{
    struct i2c_client *client = pr2000->client;

    pr2000_write_reg(client, 0xff, 0x00);
    pr2000_write_reg(client, 0xf8, 0xff);
    usleep_range(80000, 100000);
    pr2000_write_reg(client, 0xf8, 0x00);
}

static int pr2000_check_chipid(struct pr2000 *pr2000)
{
    struct i2c_client *client = pr2000->client;
    struct device *dev = &pr2000->client->dev;
    u32 msb, lsb, id;

    pr2000_write_reg(client, 0xff, 0x00);

    msb = pr2000_read_reg(client, 0xfc);
    lsb = pr2000_read_reg(client, 0xfd);

    id = (msb) << 8 | (lsb);
    if (id != CHIP_ID) {
        dev_err(dev, "Wrong pr2000 sensor id(%04x)\n", id);
        if (!IS_ERR(pr2000->pwdn_gpio))
            gpiod_set_value_cansleep(pr2000->pwdn_gpio, 1);
        return -EINVAL;
    }

    dev_info(dev, "Detected pr2000 (%04x) sensor\n", CHIP_ID);

    return 0;
}

static int pr2000_dump_status(struct pr2000 *pr2000)
{
    struct i2c_client *client = pr2000->client;
    struct device *dev = &pr2000->client->dev;
    u32 stat0, stat1, stat2, ifmt, misc;

    pr2000_write_reg(client, 0xff, 0x00);

    stat0 = pr2000_read_reg(client, 0x00);
    stat1 = pr2000_read_reg(client, 0x01);
    stat2 = pr2000_read_reg(client, 0x02);
    ifmt  = pr2000_read_reg(client, 0x10);
    misc  = pr2000_read_reg(client, 0x14);

    dev_info(dev, "Detected 0x00 = %02x, 0x01 = %02x, 0x02 = %02x, 0x10= %02x, 0x14 = %02x\n", stat0, stat1, stat2, ifmt, misc);

    return 0;
}

static int pr2000_check_mode(struct pr2000 *pr2000)
{
    int ret;
    u32 stat0, stat1;
    struct i2c_client *client = pr2000->client;
    struct device *dev = &pr2000->client->dev;

    ret = pr2000_write_array(client, pr2000_initial);
    if (ret) {
        return -EINVAL;
    }

    msleep(50);

    pr2000_write_reg(client, 0xff, 0x00);
    stat0 = pr2000_read_reg(client, 0x00);
    stat1 = pr2000_read_reg(client, 0x01);

    dev_info(dev, "Detected 0x00 = %02x, 0x01 = %02x\n", stat0, stat1);

    if ((stat0 & 0x03) == 0x00) {
        dev_info(dev, "Detected NTSC\n");
        pr2000->cur_mode = &supported_modes[0];
    } else if ((stat0 & 0x03) == 0x01) {
        dev_info(dev, "Detected PAL\n");
        pr2000->cur_mode = &supported_modes[1];
    } else if ((stat0 & 0x03) == 0x02) {
        if ((stat0 & 0x30) == 0x00) {
            dev_info(dev, "Detected 720P25\n");
            pr2000->cur_mode = &supported_modes[2];
        } else if ((stat0 & 0x30) == 0x10) {
            dev_info(dev, "Detected 720P30\n");
            pr2000->cur_mode = &supported_modes[3];
        } else if ((stat0 & 0x30) == 0x20) {
            dev_info(dev, "Detected 720P50\n");
        } else if ((stat0 & 0x30) == 0x30) {
            dev_info(dev, "Detected 720P60\n");
        }
    } else if ((stat0 & 0x03) == 0x03) {
        if ((stat0 & 0x30) == 0x00) {
            dev_info(dev, "Detected 1080P25\n");
            pr2000->cur_mode = &supported_modes[4];
        } else if ((stat0 & 0x30) == 0x10) {
            pr2000->cur_mode = &supported_modes[5];
            dev_info(dev, "Detected 1080P30\n");
        }
    } else {
        dev_info(dev, "Failed to get camera sensor reslution, use default 720x576PAL");
    }

    return 0;
}

static int pr2000_get_reso_dist(const struct pr2000_mode *mode,
				struct v4l2_mbus_framefmt *framefmt)
{
	return abs(mode->width - framefmt->width) +
	       abs(mode->height - framefmt->height);
}

static const struct pr2000_mode *
pr2000_find_best_fit(struct v4l2_subdev_format *fmt)
{
	struct v4l2_mbus_framefmt *framefmt = &fmt->format;
	int dist;
	int cur_best_fit = 0;
	int cur_best_fit_dist = -1;
	int i;

	for (i = 0; i < ARRAY_SIZE(supported_modes); i++) {
		dist = pr2000_get_reso_dist(&supported_modes[i], framefmt);
		if (cur_best_fit_dist == -1 || dist < cur_best_fit_dist) {
			cur_best_fit_dist = dist;
			cur_best_fit = i;
		}
	}

	return &supported_modes[cur_best_fit];
}

static int pr2000_set_fmt(struct v4l2_subdev *sd,
               struct v4l2_subdev_pad_config *cfg,
               struct v4l2_subdev_format *fmt)
{
    struct pr2000 *pr2000 = to_pr2000(sd);
    const struct pr2000_mode *mode;

    mutex_lock(&pr2000->mutex);

    mode = pr2000_find_best_fit(fmt);

    fmt->format.code = MEDIA_BUS_FMT_UYVY8_2X8;
    fmt->format.width = mode->width;
    fmt->format.height = mode->height;
    fmt->format.field = V4L2_FIELD_NONE;
    if (mode->interlace)
        fmt->format.field = V4L2_FIELD_INTERLACED;
    fmt->format.colorspace = V4L2_COLORSPACE_SMPTE170M; // for PAL/NTSC

    if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
        *v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
    } else {
        pr2000->cur_mode = mode;
    }

    mutex_unlock(&pr2000->mutex);
    return 0;
}

static int pr2000_get_fmt(struct v4l2_subdev *sd,
               struct v4l2_subdev_pad_config *cfg,
               struct v4l2_subdev_format *fmt)
{
    struct pr2000 *pr2000 = to_pr2000(sd);
    const struct pr2000_mode *mode = pr2000->cur_mode;

    mutex_lock(&pr2000->mutex);
    if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
        fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
    } else {
        fmt->format.width = mode->width;
        fmt->format.height = mode->height;
        fmt->format.code = MEDIA_BUS_FMT_UYVY8_2X8;
        fmt->format.field = V4L2_FIELD_NONE;
        if (mode->interlace)
            fmt->format.field = V4L2_FIELD_INTERLACED;
        fmt->format.colorspace = V4L2_COLORSPACE_SMPTE170M; // for PAL/NTSC
    }
    mutex_unlock(&pr2000->mutex);

    return 0;
}

static int pr2000_enum_mbus_code(struct v4l2_subdev *sd,
                  struct v4l2_subdev_pad_config *cfg,
                  struct v4l2_subdev_mbus_code_enum *code)
{
    if (code->index >= ARRAY_SIZE(supported_modes))
        return -EINVAL;

    code->code = MEDIA_BUS_FMT_UYVY8_2X8;
    return 0;
}

static int pr2000_enum_frame_sizes(struct v4l2_subdev *sd,
                    struct v4l2_subdev_pad_config *cfg,
                    struct v4l2_subdev_frame_size_enum *fse)
{
    if (fse->index >= ARRAY_SIZE(supported_modes))
        return -EINVAL;

    if (fse->code != MEDIA_BUS_FMT_UYVY8_2X8)
        return -EINVAL;

    fse->min_width  = supported_modes[fse->index].width;
    fse->max_width  = supported_modes[fse->index].width;
    fse->max_height = supported_modes[fse->index].height;
    fse->min_height = supported_modes[fse->index].height;

    return 0;
}

static int pr2000_g_skip_top_lines(struct v4l2_subdev *sd, u32 *lines)
{
    struct pr2000 *pr2000 = to_pr2000(sd);
    *lines = pr2000->skip_top;

    return 0;
}

static int pr2000_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)
{
    /* Only PAL now */
    *std = V4L2_STD_PAL;

    return 0;
}

static int __pr2000_power_on(struct pr2000 *pr2000)
{
    int ret;
    struct device *dev = &pr2000->client->dev;

    if (!IS_ERR(pr2000->xvclk)) {
        ret = clk_prepare_enable(pr2000->xvclk);
        if (ret < 0) {
            dev_err(dev, "Failed to enable xvclk\n");
            return ret;
        }
    }

    if (!IS_ERR(pr2000->reset_gpio))
        gpiod_set_value_cansleep(pr2000->reset_gpio, 1);

    ret = regulator_bulk_enable(PR2000_NUM_SUPPLIES, pr2000->supplies);
    if (ret < 0) {
        dev_err(dev, "Failed to enable regulators\n");
        goto disable_clk;
    }

    msleep(2);
    if (!IS_ERR(pr2000->reset_gpio))
        gpiod_set_value_cansleep(pr2000->reset_gpio, 0);

    if (!IS_ERR(pr2000->pwdn_gpio))
        gpiod_set_value_cansleep(pr2000->pwdn_gpio, 0);

    return 0;

disable_clk:
    if (!IS_ERR(pr2000->xvclk))
        clk_disable_unprepare(pr2000->xvclk);

    return ret;
}

static void __pr2000_power_off(struct pr2000 *pr2000)
{
    if (!IS_ERR(pr2000->pwdn_gpio))
        gpiod_set_value_cansleep(pr2000->pwdn_gpio, 1);
    if (!IS_ERR(pr2000->xvclk))
        clk_disable_unprepare(pr2000->xvclk);
    if (!IS_ERR(pr2000->reset_gpio))
        gpiod_set_value_cansleep(pr2000->reset_gpio, 1);
    regulator_bulk_disable(PR2000_NUM_SUPPLIES, pr2000->supplies);
}


static int pr2000_g_mbus_config(struct v4l2_subdev *sd,
			     struct v4l2_mbus_config *cfg)
{
    cfg->type = V4L2_MBUS_CSI2;

    /* Support for non-continuous CSI-2 clock is missing in the driver */
    cfg->flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
    cfg->flags |= V4L2_MBUS_CSI2_4_LANE;

    return 0;
}


static int pr2000_s_stream(struct v4l2_subdev *sd, int on)
{
    struct pr2000 *pr2000 = to_pr2000(sd);
    struct i2c_client *client = pr2000->client;
    int ret = 0;

    mutex_lock(&pr2000->mutex);

    on = !!on;
    if (on == pr2000->streaming)
        goto unlock_and_return;

    if (on) {
        ret = pm_runtime_get_sync(&pr2000->client->dev);
        if (ret < 0) {
            pm_runtime_put_noidle(&client->dev);
            goto unlock_and_return;
        }

        pr2000_soft_reset(pr2000);

        ret = pr2000_write_array(pr2000->client, pr2000->cur_mode->reg_list);
        if (ret) {
            pm_runtime_put(&client->dev);
            goto unlock_and_return;
        }

        ret = pr2000_write_array(pr2000->client, pr2000_mipi_start);
        if (ret) {
            pm_runtime_put(&client->dev);
            goto unlock_and_return;
        }

        if (pr2000->cur_mode->interlace) {
            ret = pr2000_write_reg(client, 0x47, 0xb6);
        } else {
            ret = pr2000_write_reg(client, 0x47, 0xba);
        }
        if (ret) {
            pm_runtime_put(&client->dev);
            goto unlock_and_return;
        }
        pr2000_dump_status(pr2000);
    } else {
        ret = pr2000_write_array(pr2000->client, pr2000_mipi_stop);
        pm_runtime_put(&client->dev);
    }

    pr2000->streaming = on;

unlock_and_return:
    mutex_unlock(&pr2000->mutex);

    return ret;
}


static int pr2000_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
    struct pr2000 *pr2000 = to_pr2000(sd);
    struct v4l2_mbus_framefmt *try_fmt;

    mutex_lock(&pr2000->mutex);

    try_fmt = v4l2_subdev_get_try_format(sd, fh->pad, 0);
    /* Initialize try_fmt */
    try_fmt->width = pr2000->cur_mode->width;
    try_fmt->height = pr2000->cur_mode->height;
    try_fmt->code = MEDIA_BUS_FMT_UYVY8_2X8;
    try_fmt->field = V4L2_FIELD_NONE;
    if (pr2000->cur_mode->interlace)
        try_fmt->field = V4L2_FIELD_INTERLACED;
    try_fmt->colorspace = V4L2_COLORSPACE_SMPTE170M; //V4L2_COLORSPACE_SMPTE170M

    mutex_unlock(&pr2000->mutex);

    return 0;
}

static int pr2000_runtime_resume(struct device *dev)
{
    struct i2c_client *client = to_i2c_client(dev);
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    struct pr2000 *pr2000 = to_pr2000(sd);

    return __pr2000_power_on(pr2000);
}

static int pr2000_runtime_suspend(struct device *dev)
{
    struct i2c_client *client = to_i2c_client(dev);
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    struct pr2000 *pr2000 = to_pr2000(sd);

    __pr2000_power_off(pr2000);

    return 0;
}

static const struct dev_pm_ops pr2000_pm_ops = {
    SET_RUNTIME_PM_OPS(pr2000_runtime_suspend,
               pr2000_runtime_resume, NULL)
};



static int pr2000_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)
{
    struct pr2000 *pr2000 = to_pr2000(sd);

	*std = pr2000->std;
	return 0;
}

static int pr2000_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
{
	struct pr2000 *pr2000 = to_pr2000(sd);

	pr2000->std = std;
	return 0;
}


static const struct v4l2_subdev_video_ops pr2000_video_ops = {
	.g_std = pr2000_g_std,
	.s_std = pr2000_s_std,
	.g_mbus_config = pr2000_g_mbus_config,
    .s_stream = pr2000_s_stream,
    .querystd = pr2000_querystd,
};

static const struct v4l2_subdev_pad_ops pr2000_pad_ops = {
    .enum_mbus_code = pr2000_enum_mbus_code,
    .enum_frame_size = pr2000_enum_frame_sizes,
    .get_fmt = pr2000_get_fmt,
    .set_fmt = pr2000_set_fmt,
};

static struct v4l2_subdev_sensor_ops pr2000_sensor_ops = {
    .g_skip_top_lines   = pr2000_g_skip_top_lines,
};

static const struct v4l2_subdev_ops pr2000_subdev_ops = {
    .video  = &pr2000_video_ops,
    .pad    = &pr2000_pad_ops,
    .sensor = &pr2000_sensor_ops,
};


static const struct v4l2_subdev_internal_ops pr2000_internal_ops = {
    .open = pr2000_open,
};


static int pr2000_configure_regulators(struct pr2000 *pr2000)
{
    u32 i;

    for (i = 0; i < PR2000_NUM_SUPPLIES; i++)
        pr2000->supplies[i].supply = pr2000_supply_names[i];

    return devm_regulator_bulk_get(&pr2000->client->dev,
                       PR2000_NUM_SUPPLIES,
                       pr2000->supplies);
}

static int pr2000_init_ctrls(struct pr2000 *pr2000)
{
	struct v4l2_ctrl_handler *handler;
	struct v4l2_ctrl *ctrl;
	int ret;

	handler = &pr2000->ctrl_handler;
	ret = v4l2_ctrl_handler_init(handler, 2);
	if (ret)
		return ret;
	handler->lock = &pr2000->mutex;

	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
				      0, 0, link_freq_menu_items);
	if (ctrl)
		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;

	v4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE,
			  0, PR2000_PIXEL_RATE, 1, PR2000_PIXEL_RATE);

	if (handler->error) {
		ret = handler->error;
		dev_err(&pr2000->client->dev,
			"Failed to init controls(%d)\n", ret);
		goto err_free_handler;
	}

	pr2000->subdev.ctrl_handler = handler;

	return 0;

err_free_handler:
	v4l2_ctrl_handler_free(handler);

	return ret;
}

static int pr2000_probe(struct i2c_client *client,
             const struct i2c_device_id *id)
{
    struct device *dev = &client->dev;
    struct pr2000 *pr2000;
    int ret;

    pr2000 = devm_kzalloc(dev, sizeof(*pr2000), GFP_KERNEL);
    if (!pr2000)
        return -ENOMEM;

    pr2000->skip_top = PR2000_SKIP_TOP;

    pr2000->client = client;
    pr2000->cur_mode = &supported_modes[0];

    pr2000->xvclk = devm_clk_get(dev, "xvclk");
    if (!IS_ERR(pr2000->xvclk)) {
        ret = clk_set_rate(pr2000->xvclk, PR2000_XVCLK_FREQ);
        if (ret < 0) {
            dev_err(dev, "Failed to set xvclk rate (27MHz)\n");
            return ret;
        }
        if (clk_get_rate(pr2000->xvclk) != PR2000_XVCLK_FREQ)
            dev_warn(dev, "xvclk mismatched, it requires 27MHz\n");
    }

    pr2000->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
    if (IS_ERR(pr2000->reset_gpio)) {
		dev_warn(dev, "Failed to get reset-gpios\n");
    }

    pr2000->pwdn_gpio = devm_gpiod_get(dev, "pwdn", GPIOD_OUT_LOW);
    if (IS_ERR(pr2000->pwdn_gpio)) {
		dev_warn(dev, "Failed to get pwdn-gpios\n");
    }

    ret = pr2000_configure_regulators(pr2000);
    if (ret) {
        dev_err(dev, "Failed to get power regulators\n");
        return ret;
    }

    mutex_init(&pr2000->mutex);
    v4l2_i2c_subdev_init(&pr2000->subdev, client, &pr2000_subdev_ops);
    ret = pr2000_init_ctrls(pr2000);
    if (ret)
        goto err_destroy_mutex;

    ret = __pr2000_power_on(pr2000);
    if (ret)
        goto err_destroy_mutex;

    ret = pr2000_check_chipid(pr2000);
    if (ret)
        goto err_power_off;

    ret = pr2000_check_mode(pr2000);
    if (ret)
        goto err_power_off;

    pr2000->subdev.internal_ops = &pr2000_internal_ops;
    pr2000->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
    pr2000->pad.flags = MEDIA_PAD_FL_SOURCE;
    pr2000->subdev.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
    ret = media_entity_init(&pr2000->subdev.entity, 1, &pr2000->pad, 0);
    if (ret < 0)
        goto err_power_off;

    ret = v4l2_async_register_subdev(&pr2000->subdev);
    if (ret) {
        dev_err(dev, "v4l2 async register subdev failed\n");
        goto err_clean_entity;
    }

    pm_runtime_set_active(dev);
    pm_runtime_enable(dev);
    pm_runtime_idle(dev);

    return 0;

err_clean_entity:
    media_entity_cleanup(&pr2000->subdev.entity);
err_power_off:
    __pr2000_power_off(pr2000);
err_destroy_mutex:
    mutex_destroy(&pr2000->mutex);

    return ret;
}

static int pr2000_remove(struct i2c_client *client)
{
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    struct pr2000 *pr2000 = to_pr2000(sd);

    v4l2_async_unregister_subdev(sd);
    media_entity_cleanup(&sd->entity);
    mutex_destroy(&pr2000->mutex);

    pm_runtime_disable(&client->dev);
    if (!pm_runtime_status_suspended(&client->dev))
        __pr2000_power_off(pr2000);
    pm_runtime_set_suspended(&client->dev);

    return 0;
}

static const struct i2c_device_id pr2000_id[] = {
    {"pr2000", 0},
    {},
};

#if IS_ENABLED(CONFIG_OF)
static const struct of_device_id pr2000_of_match[] = {
    { .compatible = "pixelplus,pr2000" },
    {},
};
MODULE_DEVICE_TABLE(of, pr2000_of_match);
#endif

static struct i2c_driver pr2000_i2c_driver = {
    .driver = {
        .name = "pr2000",
        .pm = &pr2000_pm_ops,
        .of_match_table = pr2000_of_match
    },
    .probe      = pr2000_probe,
    .remove     = pr2000_remove,
    .id_table   = pr2000_id,
};

static int __init pr2000_init(void)
{
	return i2c_add_driver(&pr2000_i2c_driver);
}

static void __exit pr2000_exit(void)
{
	i2c_del_driver(&pr2000_i2c_driver);
}

device_initcall_sync(pr2000_init);

MODULE_DESCRIPTION("pr2000 sensor driver");
MODULE_LICENSE("GPL v2");
